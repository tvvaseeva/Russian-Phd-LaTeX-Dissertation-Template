\chapter{Основные свойства весовых функций}\label{app:А}

%\section{Основные свойства весовых функций}\label{app:A1}

%\fontsize{10pt}{10pt}\selectfont
%\begin{longtable*}[c]{|l|c|c|c|l|} 
%	\hline
%	Окно 
%	& $\bigtriangleup F_{0}$ 
%	& $\bigtriangleup F_{0,5}$ 
%	& $\gamma_{ max}$ 
%	& Выражение оконной функци    \\ \hline
%	
%	прямоугольное окно & $2$ & $0,87$ & $-13,3$ & $w(n) = 1$  \\ 
%		
%	Кайзера ($\beta = 4$) 
%
%	 & $8$ & $1,12$ & $-30$ & \multirow{4}{*}{$w(n) = \cfrac{\left| {I_{0} \left( {\beta \sqrt{1 - {\left( \cfrac{2n -N -1}{N-1} \right)}^2  }}\right) }\right| }{\left| {I_{0}(\beta)}\right|}$} \\ %\cline{1-4}
%	 	 	
%	Кайзера ($\beta = 7$) 
%
%	& $8$ & $1,38$ & $-51,2$ &  \\ %\cline{1-4}
% 
%	Кайзера ($\beta = 10$) 
%
%	& $8$ & $1,96$ & $-90$ &  \\ %\cline{1-4}
%	
%	Кайзера ($\beta = 15$) 
%
%	& $8$ & $2,0$ & $-114,1$ &  \\ %\cline{1-4}
%	
%%	& & & &
%%	$I_{0}$ -- модифицированная функция Бесселя первого рода нулевого порядка.
%%	\\ \hline
%	
%	треугольное окно & 4 & $1,25$ & $-26,5$ 
%	& $w(n) = 
%	\begin{cases}
%	\frac{2n-1}{N} & 1\leq n \leq \frac{N}{2} \\
%	\frac{2(N-n+1)}{N} & \frac{N}{2}+1 \leq N
% 	\end{cases}$  \\ 
% 
% 	Блэкмана-Харриса & $8$ & $1,97$ & $-92$ & $w(n) = a_{0} + a_{1} \cos (\frac{2 \pi n}{N-1}) + a_{2} \cos (\frac{4 \pi n}{N-1}) + a_{2} \cos (\frac{6 \pi n}{N-1})$  \newline
% 
%% 	$a_{0} = 0,35875$;
% 	
%% 	$a_{1} = 0,48829$;
% 	
%% 	$a_{2} = 0,14128$; \newline
% 	
%% 	$a_{3} = 0,01168$.  
% 	\\ 
% 
%	Барлетта & $4$ & $1,33$ & $-26,5$ & $w_{n} = 1 - \left| {\frac{n}{\frac{N-1}{2}}}-1 \right| $ 
%	 \\
% 
%	Тьюки & $4$ & $1,22$ & $-15,1$ &	
%	%$w_{n} = 0,5 \cdot \left(  1 - \cos \left(  \frac{4 \pi \cdot (n-1)}{N-1}\right) \right)  $ \\
%	
%	%при $1\leq n \leq \frac{N-1}{4}$ \\
%
%	%$ w_{n} = 1$, при $\frac{N-1}{4} + 1\leq n \leq N - \frac{N-1}{4}$ \\
%
%	$w_{n} = 0,5 \cdot \left(  1 - \cos \left(  \frac{4 \pi \cdot (n-N)}{N-1}\right) \right)  $ при $N - \frac{N-1}{4} \leq n \leq N$ \\
%
%	Бомена & $4$ & $1,75$ & $-46$ &
%	
%	$ w_{n} = 
%	\left( 1 - 
%	\left| \frac{n-1 - \frac{N}{2}}{\frac{N}{2}}
%	 \right|  
%	\right) \times $
%	
%	$\cos 
%	\left(
%	\pi \cdot \frac{n-1 - \frac{N}{2}}{\frac{N}{2}}	
%	\right) $
%	
%	$+ \frac{1}{\pi} \sin \left( 1 - 
%	\left| \frac{n-1 - \frac{N}{2}}{\frac{N}{2}}
%	\right|  
%	\right)$
%	\\
%
%	Барлетта-Ханна & $4$ & $1,38$ & $-35,9$ &	
%	$ w_{n} = a_{0} -a_{1} 
%	\left| \frac{n}{N-1} - 0,5
%	\right| - a_{2} \cos \left( \frac{2\pi n}{N-1}
%	\right)
%	$ 
%	$a_{0}=0,62$
%	$a_{1}=0,48$
%%	$a_{2}=0,38$
%	\\
%	
%	Чебышева ($\beta = 40$) & $8$ & $1,23$&
%	 $-40$ & $w_{n} = -1^n 
%	 \frac{\cos\left( N \cdot \arccos (B \cdot \cos \frac{\pi \cdot n}{N}) \right)}{\ch (N \cdot \ch (B)^{-1})}
%	 $ \\
%	 
%	Чебышева ($\beta = 80$) & $8$ & $1,62$&
%	$-80$ & $B = \ch 
%	\left( \frac{1}{N} \ch{(10^{\beta})}^{-1}
%	\right)$ \\
%	 
%	Хэмминга & $4$ & $1,33$&
%	 $-42$ & $w_{n} = 0,54 - 0,46 \cos \left( 2 \pi \frac{n-1}{N-1}
%	 \right)
%	 $ \\
%	
%	Ханна & $4$ & $1,5$ & $-31,5$&
%	$w_{n} = 0,5 - 0,5 \cos 
%	\left( 2 \pi \frac{n-1}{N-1}
%	 \right) + 0,08 \cos \left( 4 \pi \frac{n-1}{N-1}
%	 \right) 
%	$ \\
%	
%	Чебышева ($\sigma = 0,3$) & $8$ & $1,82$ & $-65$ & 	$w_{n} = \exp \left( -0,5 \cdot  
%	{\left( \frac{n-\frac{N-1}{2}}{\sigma \cdot \frac{N-1}{2} }\right)}^2 
%	\right) $\\
%	
%	Чебышева ($\sigma = 0,5$) & $3,4$ & $1,2$ & $-31,5$ &  \\
%\hline
%\end{longtable*}


\begingroup % Ограничиваем область видимости arraystretch
\renewcommand{\arraystretch}{1.6}%% Увеличение расстояния между рядами, для улучшения восприятия.
\begin{longtabu} to \textwidth
	{%
		@{}>{\setlength{\baselineskip}{0.7\baselineskip}}X[1.1mc]%
		@{}>{\setlength{\baselineskip}{0.7\baselineskip}}X[1.1mc]%
		@{}>{\setlength{\baselineskip}{0.7\baselineskip}}X[1.1mc]%		
		>{\setlength{\baselineskip}{0.7\baselineskip}}X[1.1mc]%
		X[4]@{}%
	}
	%\caption{Основные свойства весовых функций.\label{tab:test-functions}}\\% label всегда желательно идти после caption
	
	\toprule     %%% верхняя линейка
	Окно 
	& $\bigtriangleup F_{0}$ 
	& $\bigtriangleup F_{0,5}$ 
	& $\gamma_{ max}$ 
	& Выражение оконной функци    \\
	
	\midrule %%% тонкий разделитель. Отделяет названия столбцов. Обязателен по ГОСТ 2.105 пункт 4.4.5
	\endfirsthead
	
	\multicolumn{5}{c}{\small\slshape (продолжение)}        \\
	\toprule     %%% верхняя линейка
	Окно 
	& $\bigtriangleup F_{0}$ 
	& $\bigtriangleup F_{0,5}$ 
	& $\gamma_{ max}$ 
	& Выражение оконной функци    \\

	\midrule %%% тонкий разделитель. Отделяет названия столбцов. Обязателен по ГОСТ 2.105 пункт 4.4.5
	\endhead
	
	\multicolumn{5}{c}{\small\slshape (окончание)}        \\
	\toprule     %%% верхняя линейка
	Окно 
	& $\bigtriangleup F_{0}$ 
	& $\bigtriangleup F_{0,5}$ 
	& $\gamma_{ max}$ 
	& Выражение оконной функци    \\
	
	\midrule %%% тонкий разделитель. Отделяет названия столбцов. Обязателен по ГОСТ 2.105 пункт 4.4.5
	\endlasthead
	
	\bottomrule %%% нижняя линейка
	\multicolumn{5}{r}{\small\slshape продолжение следует}  \\
	\endfoot
	\endlastfoot
	
	Прямоугольное окно & $2$ & $0,87$ & $-13,3$ &
	\(\begin{aligned}
	w(n) = 1
	\end{aligned}\) \\

	Треугольное окно & $4$ & $1,25$ & $-26,5$ & 
	$w(n) = 
	\begin{cases*}
	\frac{2n-1}{N} & \( 1\leq n \leq \frac{N}{2} \) \\[-0.5em]
	\frac{2(N-n+1)}{N} & \( \frac{N}{2}+1 \leq N \)
	\end{cases*} $  \\
	
	Барлетта & $4$ & $1,33$ & $-26,5$ & 
	\(\begin{aligned}
		\textstyle w_{n} = 1 - \left| {\frac{n}{\frac{N-1}{2}}}-1 \right| 	
	\end{aligned}\) \\
		
	Кайзера ($\beta = 4$) 
	& $8$ & $1,12$ & $-30$ & \multirow{4}{*}{
	\(\begin{aligned}
		\textstyle w(n) = \cfrac{\left| {I_{0} \left( {\beta \sqrt{1 - {\left( \cfrac{2n -N -1}{N-1} \right)}^2  }}\right) }\right| }{\left| {I_{0}(\beta)}\right|}
	\end{aligned}\) }\\

	Кайзера ($\beta = 7$) 
	& $8$ & $1,38$ & $-51,2$ & \\ 
	
	Кайзера ($\beta = 10$) 
	& $8$ & $1,96$ & $-90$ &   \\ 
	
	Кайзера ($\beta = 15$) 
	& $8$ & $2,0$ & $-114,1$ & $I_{0}$ -- модифицированная функция Бесселя первого рода нулевого порядка. \\

 	Блэкмана- & $8$ & $1,97$ & $-92$ &
 	\multirow{2}{*}{ 
	$ w(n) = a_{0} + a_{1} \cos (\frac{2 \pi n}{N-1}) + a_{2} \cos (\frac{4 \pi n}{N-1}) + 
	a_{2} \cos (\frac{6 \pi n}{N-1})	
	$}\\
	
	Харриса & & & &
 	$a_{0} = 0,35875$; 
 	$a_{1} = 0,48829$; 

 	$a_{2} = 0,14128$; 
 	$a_{3} = 0,01168$.  
\\ 

	Тьюки & $4$ & $1,22$ & $-15,1$ &
	\multirow{1}{*}{	
	$w_{n} = 0,5 \cdot \left(  1 - \cos \left(  \frac{4 \pi \cdot (n-1)}{N-1}\right) \right)$, 
	при $1\leq n \leq \frac{N-1}{4}$ }\\ 
%	$ w_{n} = 1$, при $\frac{N-1}{4} + 1\leq n \leq N - \frac{N-1}{4}$

%	$w_{n} = 0,5 \cdot \left(  1 - \cos \left(  \frac{4 \pi \cdot (n-N)}{N-1}\right) \right) $ 
%	при $N - \frac{N-1}{4} \leq n \leq N$ \\
	
	Бомена & $4$ & $1,75$ & $-46$ &
	
	$ w_{n} = 
	\left( 1 - 
	\left| \frac{n-1 - \frac{N}{2}}{\frac{N}{2}}
	\right|  
	\right) \times $
	
	$\cos 
	\left(
	\pi \cdot \frac{n-1 - \frac{N}{2}}{\frac{N}{2}}	
	\right) $
	
	$+ \frac{1}{\pi} \sin \left( 1 - 
	\left| \frac{n-1 - \frac{N}{2}}{\frac{N}{2}}
	\right|  
	\right)$
	\\
	
	Барлетта-Ханна & $4$ & $1,38$ & $-35,9$ &	
	$ w_{n} = a_{0} -a_{1} 
	\left| \frac{n}{N-1} - 0,5
	\right| - a_{2} \cos \left( \frac{2\pi n}{N-1}
	\right)
	$ 
	$a_{0}=0,62$
	$a_{1}=0,48$
	%	$a_{2}=0,38$
	\\
	
	Чебышева ($\beta = 40$) & $8$ & $1,23$&
	$-40$ & $w_{n} = -1^n 
	\frac{\cos\left( N \cdot \arccos (B \cdot \cos \frac{\pi \cdot n}{N}) \right)}{\ch (N \cdot \ch (B)^{-1})}
	$ \\
	
	Чебышева ($\beta = 80$) & $8$ & $1,62$&
	$-80$ & $B = \ch 
	\left( \frac{1}{N} \ch{(10^{\beta})}^{-1}
	\right)$ \\
	
	Хэмминга & $4$ & $1,33$&
	$-42$ & $w_{n} = 0,54 - 0,46 \cos \left( 2 \pi \frac{n-1}{N-1}
	\right)
	$ \\
	
	Ханна & $4$ & $1,5$ & $-31,5$&
	$w_{n} = 0,5 - 0,5 \cos 
	\left( 2 \pi \frac{n-1}{N-1}
	\right) + 0,08 \cos \left( 4 \pi \frac{n-1}{N-1}
	\right) 
	$ \\
	
	Чебышева ($\sigma = 0,3$) & $8$ & $1,82$ & $-65$ & 	
	\multirow{2}{*}{
	$w_{n} = \exp \left( -0,5 \cdot  
	{\left( \frac{n-\frac{N-1}{2}}{\sigma \cdot \frac{N-1}{2} }\right)}^2 
	\right) $}\\
	
	Чебышева ($\sigma = 0,5$) & $3,4$ & $1,2$ & $-31,5$ &  \\

	\bottomrule %%% нижняя линейка
\end{longtabu}

\chapter{Программа для расчета гармоник и интергармоник тока и напряжения электрической сети прямым корреляционным методом с использованием быстрых алгоритмов обработки сигналов}\label{app:Б}

\begin{lstlisting} 
from numpy import array, random, kaiser, zeros, cos, angle, absolute
from numpy.core.umath import pi
from numpy.fft import fft
from matplotlib.pyplot import figure, title, plot, xlim, show

#
#       a test signal generation
#

# signal parameters
n = 2048
harmonics = array([3, 20.1, 35.3, 51.5, 66.9])
amplitudes = array([10, 3, 1, 1, 0.2])
phases = array([0, pi/2, pi/4, pi/6, pi/8])

# generation
signal = zeros(n)
noise = random.normal(0, 0.5, n)   # powerful noise
for i in range(n):
    for j in range(len(harmonics)):
        signal[i] = signal[i] + amplitudes[j] * cos(2 * pi * harmonics[j] * i / n + phases[j])
signal = signal+noise
spectrum = fft(signal)      # for test purpose

#
#       main part, analise of signal
#

#       algorithm parameters
# window parameters
kaiser_beta = 14            # kaiser window beta
exp_ratio = 2048            # expansion ratio
delta = 5                   # delta of window for peak detection
threshold_level = 0.01      # harmonic threshold
width_window = 10           # width of window
# peak finding parameters
peak_group_distance = 5     # to find candidate to peak
peak_area_distance = 100    # to find maximum of peak

#       window
# calculate window
window = kaiser(n+1, kaiser_beta)   # create symmetric window
window_factor = pi*sum(window)/n    # window factor
# apply window to reduce a number of peak
signal2 = signal * window[0:n]

#       on board calculation
# expand signal (add zeros)
signal3 = zeros(n * exp_ratio)
signal3[0:n] = signal2
# find spectrum of the expanded signal
# use SFFT (https://groups.csail.mit.edu/netmit/sFFT/index.html) for fast calculation
spectrum3 = 2 * pi * fft(signal3) / n

#       find peak in region of interest
sp = lambda x: abs(spectrum3[x])    # for brevity
# find peak candidate
peaks = []
for i in range(100 * exp_ratio):
    if (sp(i) < sp(i + delta))\
            & (sp(i + delta) < sp(i + 2 * delta)) \
            & (sp(i + 2 * delta) > sp(i + 3 * delta))\
            & (sp(i + 3 * delta) > sp(i + 4 * delta)):
        peaks.append(i + delta)
# find groups of peak
groups = []
i = 0
while i < len(peaks):
    s = set()
    groups.append(s)
    s.add(peaks[i])
    i += 1
    while peaks[i] - peaks[i - 1] < peak_group_distance:
        s.add(peaks[i])
        i += 1
        if i == len(peaks):
            break
# find true peak
true_peaks = []
for group in groups:
    middle = sum(group)//len(group)
    harm_range = range(middle - peak_area_distance // 2,
                       middle + peak_area_distance // 2)
    ind = 0
    max = 0
    for harm in harm_range:
        if sp(harm) > max:
            ind = harm
            max = sp(harm)
    true_peaks.append(ind)
# clear small peak
real_peaks = []
threshold = 0
for peak in true_peaks:
    if sp(peak) > threshold:
        threshold = sp(peak)
threshold = threshold * threshold_level
for peak in true_peaks:
    if sp(peak) > threshold:
        real_peaks.append(peak)
# find_harmonics
found_harmonics = zeros(len(real_peaks))
found_amplitudes = zeros(len(real_peaks))
fond_phase = zeros(len(real_peaks))
for i in range(len(real_peaks)):
    peak = real_peaks[i]
    found_harmonics[i] = (peak / exp_ratio)
    harmonic = spectrum3[peak]/window_factor
    found_amplitudes[i] = (absolute(harmonic))
    fond_phase[i] = (angle(harmonic, deg=True))

#
#       results and graphics
#

print(found_harmonics)
print(found_amplitudes)
print(fond_phase)

errors_harmonics = abs(found_harmonics-harmonics)
errors_amplitudes = 100*abs(found_amplitudes-amplitudes)/amplitudes
errors_phase = abs(fond_phase-180*phases/pi)
print("Harmonics error")
print(errors_harmonics)
print("Amplitudes error, % ")
print(errors_amplitudes)
print("Phase error, degree ")
print(errors_phase)
# plot parameters
fmax = 100

figure(1)
title("signal")
plot(signal)

figure(2)
title("spectrum of expanded signal")
plot(abs(spectrum3))
xlim(0, fmax * exp_ratio)

show()
\end{lstlisting}

\chapter{Свидетельство о государственной регистрации программ для ЭВМ}\label{app:В}
\begin{figure}[ht]
	\centering
	\includegraphics [scale=0.70] {Computer_program.jpg}
	\caption{Программа.}
	\label{img:Computer_program}
\end{figure}

\chapter{Оценка дисперсии белого шума после наложения на него окна}\label{app:Г}
\begin{lstlisting}
import matplotlib.pyplot as plt
import numpy as np

n_point = 1000
n_test = 100

variances = [0.1 * i for i in range(11)]
n_var = len(variances)

real_variances = np.zeros(n_var)

kaiser_beta = 15  # kaiser window beta

window_tmp = np.kaiser(n_point + 1, kaiser_beta)  # create symmetric window

window = window_tmp[0:n_point]
window_factor = np.pi * sum(window) / n_point  # window factor
window_mean_2 = np.sum([window[i]**2 for i in range(n_point)])/n_point

for i_var in range(n_var):
for i_test in range(n_test):
noise = np.random.normal(0, np.sqrt(variances[i_var]), n_point)
real_variances[i_var] += np.var(noise * window)

real_variances /= n_test

print(variances)
print(real_variances)

plt.plot(variances, np.multiply(variances, window_mean_2), color = 'red',label = u'результаты моделирования')
plt.plot(variances, real_variances, linestyle='dashed', color = 'blue', label = u'результаты расчета по формуле')
plt.title("Зависимость дисперсии шума после наложения окна от параметра окна")
plt.ylabel("Параметр окна Кайзера(beta=15)")
plt.xlabel("Дисперсия амплитуды")
plt.legend()   # легенда для всего рисунка fig
plt.grid()
plt.show()
\end{lstlisting}

\chapter{Оценка амплитуды при использовании разных окон}\label{app:Д}
\begin{lstlisting}
import matplotlib.pyplot as plt
import numpy as np

n_point = 1024
n_test = 1000
n_beta = 20
betas = [(i + 1) * 1 for i in range(n_beta)]

variance = 1
amp = 5
freq = 3

crlb = [variance / (n_point / 2) for _ in range(n_beta)]
errors_mean = np.zeros(n_beta)
errors_var = np.zeros(n_beta)
window_factors = np.zeros(n_beta)
window_factors_2 = np.zeros(n_beta)
window_mean_2 = np.zeros(n_beta)

i_space = range(n_point)

for i_betas in range(n_beta):
    kaiser_beta = betas[i_betas]
    window_tmp = np.kaiser(n_point + 1, kaiser_beta)  # create symmetric window
    window = window_tmp[0:n_point]
    window_spec = np.fft.fft(window) / n_point
    window_factors[i_betas] = np.sum(window) / n_point  # abs(window_spec[0])
    window_mean_2[i_betas] = np.sum([window[i] ** 2 for i in range(n_point)]) / n_point

    for i_test in range(n_test):
        noise = np.random.normal(0, np.sqrt(variance), n_point)
        signal = amp * np.sin([2 * np.pi * freq * i / n_point + np.pi/4 for i in range(n_point)])
        signal_noise_win = (signal + noise) * window
        spectrum = 2 * np.fft.fft(signal_noise_win) / n_point
        amp_est = abs(spectrum[freq]) / window_factors[i_betas]
        errors_var[i_betas] += (abs(amp_est) - amp) ** 2
        errors_mean[i_betas] += (abs(amp_est) - amp)

errors_mean /= n_test
errors_var /= n_test

print(window_factors)
print(window_mean_2)

plt.plot(betas, crlb * window_mean_2 / (window_factors * window_factors), color = 'red', label = u'результаты расчета по формуле')
plt.plot(betas, errors_var, color='blue', linestyle='dashed', label = u'результаты моделирования')
plt.title("Зависимость дисперсии оценки амплитуды от параметра окна")
plt.ylabel("Дисперсия шума")
plt.xlabel("Дисперсия амплитуды (variance)")
plt.grid()
plt.legend()
plt.show()
\end{lstlisting}

\chapter{Оценки амплитуды при различных уровнях шума}\label{app:Е}
\begin{lstlisting}
import matplotlib.pyplot as plt
import numpy as np

n_point = 1024
n_test = 1000
n_var = 10
variances = [(i + 1) * 1 for i in range(n_var)]

beta = 15
amp = 10
freq = 7

crlb = np.array([variances[i] / (n_point / 2) for i in range(n_var)])
errors_mean = np.zeros(n_var)
errors_var = np.zeros(n_var)

kaiser_beta = beta
window_tmp = np.kaiser(n_point + 1, kaiser_beta)  # create symmetric window
window = window_tmp[0:n_point]
window_spec = np.fft.fft(window) / n_point
window_factors = np.sum(window)/ n_point  # abs(window_spec[0])
window_mean_2 = np.sum([window[i] ** 2 for i in range(n_point)]) / n_point

for i_var in range(n_var):
for i_test in range(n_test):
noise = np.random.normal(0, np.sqrt(variances[i_var]), n_point)
signal = amp * np.sin([2 * np.pi * freq * i / n_point for i in range(n_point)])
signal_noise_win = (signal + noise) * window
spectrum = 2 * np.fft.fft(signal_noise_win) / n_point
amp_est = abs(spectrum[freq]) / window_factors
errors_var[i_var] += (abs(amp_est) - amp) ** 2
errors_mean[i_var] += (abs(amp_est) - amp)

errors_mean /= n_test
errors_var /= n_test

plt.plot(variances, errors_var, color='red',linestyle='dashed', label = u'результаты моделирования')
plt.plot(variances, crlb * window_mean_2 / (window_factors * window_factors), color='blue',label = u'результаты расчета по формуле')
plt.plot(variances, crlb, color='green', linestyle='dotted',label = u'Граница Крамера-Рао')
#plt.title("Зависимость дисперсии оценки амплитуды от дисперсии шума")
plt.title("Окно Кайзера") #Kaiser window
plt.ylabel("Дисперсия шума")
plt.xlabel("Дисперсия амплитуды")
plt.grid()
increase_variances = window_mean_2 / (window_factors * window_factors)
print("increase_variances=", increase_variances)
plt.legend()
plt.show()	
\end{lstlisting}


\chapter{Алгоритм вычисления одномерной свертки}\label{app:Ж}
\begin{lstlisting}
#include <stdio.h>                                  // библиотека ввода и вывода на экран
#include <string.h>                                 // стандартная библиотека работы со строками
#include <math.h>                                   // математическая библиотека
#include <time.h>                                   // библиотеке работы с датой и временем
#include <chrono>                                   // библиотека времени(длительность, время, часы)
#include <iostream>


//      Глобальные переменные
// Константы
#define NRUN 1000                                     // Директива, количество запусков
#define NH1 100                                       // Директива, длина фильтра (начальное значение)
#define NH2 1000                                      // Директива, длина фильтра (конечное значение)
#define NHstep 100                                    // Директива,  шаг длина фильтра NH

#define NX1 1000                                      // Директива, длина сигнала (начальное значение)
#define NX2 3000                                      // Директива, длина сигнала (начальное значение)
#define NXstep 1000                                   // Директива,  шаг длина сигнала NX


int _nout;                                            // Длина результата
int _nh;                                              // текущая длина фильтра
float h[NH2];                                         // Одномерный массив h, с длинной NH=1000
float x[NX2];                                         // Одномерный массив x, с длинной NX=3000
float dir_out[NX2-NH2+1];                             // Одномерный массив dir_out результат, с длинной NOUT
float result[NH2/NHstep][NX2/NXstep];                 // Результаты измерения времени

//      Для проверки правильности работы методов

void fill_array(float* arr, int n) {                  // Функция fill_array
    int i;
    for (i = 0; i < n; i++)                           // Цикл for (инициализация; условие; шаг)
        arr[i] = i + 1;
}
void print_array(float*arr, int n){                   // Печать функция fill_array
    int i;
    for (i = 0; i < n; i++)
        printf("%f \n", arr[i]);
}
//      Реализация 1D свертки (Convolution)
void dir_conv() {
    int i,j;
    for (i = 0; i < _nout; i++) {
        float sum = 0;
        float*ph = h;
        float*px = x + i;
        for (j = 0; j < _nh; j++)
            sum += *ph++ * *px++;
        dir_out[i] = sum;

    }
}

//       Подсчет времени функции
std::chrono::milliseconds measure_func_time(void(*f)()) {// продолжительность в миллисекундах, соотношение 1: 1000 с секундами
    using clock = std::chrono::high_resolution_clock;    // high_resolution_clock-часы с высоким разрешением
    clock::time_point start = clock::now();              // time_point-момент времени
    (*f)();
    clock::time_point end = clock::now();
    return std::chrono::duration_cast<std::chrono::milliseconds>(end - start );    //duration_cast-длительность
}

void test_func(){
    for(int j=0; j<NRUN; j++) {            			      // loops - количество повторений
        dir_conv();
    }
}

void convolv_time(){
    std::chrono::milliseconds duration;
    for (int nx = NX1; nx < NX2; nx+=NXstep){
        fill_array(x, nx);
        printf("nx - %i \n",nx);
        for (int nh = NH1; nh < NH2; nh+=NHstep) {
            fill_array(h, nh);
            printf("    nh - %i \n",nh);
            _nout = nx-nh+1;                              // длина сигнала на выходе
            _nh = nh;                                     // длина фильтра
            duration = measure_func_time(&test_func);     // тестирование ф-и
            result[(nh-NH1)/NHstep][(nx-NX1)/NXstep] = duration.count();
        }
    }
}
// Функция сохранения в csv
void convolv_csv(int row, int col, float *matrix, char *file_name) {
    int i, j;
    FILE *file;
    file = fopen(file_name, "w");
    if (file == 0)
        printf("file error");
    for (i = 0; i < row; i++) {
        for (j = 0; j < col; j++)
            fprintf(file, "%f; ", matrix[i*col+j]);
        fprintf(file, "\n");
    }
}

int main()
{
    convolv_time();
    char file_name[] = "convolution.csv";
    convolv_csv(NH2/NHstep, NX2/NXstep, (float*)result, file_name);
    return  0;                                                // Возврат результата
}

\end{lstlisting}


%\chapter{Акт о внедрении результатов диссертационной работы}\label{app:И}

